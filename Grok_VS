oc delete vs 000-kill-everything-now -n dev-istio-system --ignore-not-found=true
cat <<EOF | oc apply -f -
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: 000-kill-everything-now
  namespace: dev-istio-system
spec:
  gateways:
  - epay-dev-gateway
  hosts:
  - dev.epay.sbi
  exportTo:
  - "*"
  http:
  - match:
    - uri:
        prefix: "/"
    route:
    - destination:
        host: maintenancefe-maintenance-frontend.dev-frontend.svc.cluster.local
        port:
          number: 8080
EOF
[osuser@bastion ~]$ oc apply -f grook-vs.yaml
The VirtualService "zzz-global-maintenance-override" is invalid: spec.http[0].fault.abort.percentage: Invalid value: "integer": spec.http[0].fault.abort.percentage in body must be of type object: "integer"



[osuser@bastion ~]$ oc apply -f grook-vs.yaml
Error from server: error when creating "grook-vs.yaml": admission webhook "rev.validation.istio.io" denied the request: configuration is invalid: cannot have both public (*) and non-public exportTo values for a resource







https://teams.microsoft.com/l/meetup-join/19%3ameeting_MTZkMTFhNTMtZWFiMy00MTM1LTk1YTYtMmNjNGI3MjZkM2U3%40thread.v2/0?context=%7b%22Tid%22%3a%22fbdb2235-7f50-4509-b407-c58325ec27a8%22%2c%22Oid%22%3a%223aca8f16-6e14-4d04-96f7-c4680458f4cc%22%7d















The Virtual Service is correct but there is one problem when we put the whole configuration together. The routing rules for this host dev.epay.sbi is not defined in a single Virtual Service and we cannot determine their order of precedence, ideally, when they are defined in a single file they are evaluated in sequential order from top to bottom.

Given the above configuration (5 VSs in dev-frontend NS + the VS in dev-istio-system), when a client access the application --> https://dev.epay.sbi/transactiontracking the request is forwarded to websitefe-epay-website svc as the matching rule is more specific and taking more precedence over what is defined in the VS in dev-istio-system for routing the request to maintenancefe-maintenance-frontend.dev-frontend.svc.cluster.local svc.

Suggestion

Delete all the Virtual Services in dev-frontend that are defining the host dev.epay.sbi individually.
Merge all the Virtual service that are defining the same host in a single file.[2]
During the maintenance period keep the following Virtual Service only that will route the traffic to the maintenance service.




apiVersion: networking.istio.io/v1
kind: VirtualService
metadata:
  name: <vs-name>
  namespace: dev-frontend
spec:
  gateways:
  - dev-istio-system/epay-dev-gateway
  hosts:
  - dev.epay.sbi
  http:
  - match:
    - uri:
        prefix: /merchantintegration/
    route:
    - destination:
        host: integration
        port:
          number: 8080
  - match:
    - uri:
        prefix: /maintenance
    route:
    - destination:
        host: maintenancefe-maintenance-frontend
        port:
          number: 8080     
  - match:
    - uri:
        prefix: /ui/
    route:
    - destination:
        host: transactionfe-transaction-frontend
        port:
          number: 8080
  - match:
    - uri:
        prefix: /merchantpanel
    route:
    - destination:
        host: merchantfe-merchant-frontend
        port:
          number: 8080
  - match:
    - uri:
        prefix: /transactiontracking
    route:
    - destination:
        host: websitefe-epay-website
        port:
          number: 8080 








apiVersion: networking.istio.io/v1
kind: VirtualService
metadata:
  name: <vs-name>
  namespace: dev-frontend
spec:
  gateways:
  - dev-istio-system/epay-dev-gateway
  hosts:
  - dev.epay.sbi
  http:
  - match:
    - uri:
        prefix: /
    route:
    - destination:
        host: maintenancefe-maintenance-frontend.dev-frontend.svc.cluster.local
        port:





Perfect.
I now have everything needed to generate complete, polished, enterprise-grade responses for all questions shown in your screenshot â€” tailored to:

GitLab CI/CD

GitFlow (dev â†’ SIT â†’ UAT â†’ pre-prod â†’ prod â†’ DR/DC)

Helm charts

OpenShift (RHOCP)

Quay registry

Manual vulnerability remediation

Local conflict resolution

Helm rollback + previous image tags



---

âœ… Final Answers to All Questionnaire Items (Clean, Professional, Ready to Submit)

Below are the answers to the exact questions visible in your screenshot.


---

1. Are there any existing branch protection rules, naming conventions, or merge policies?

Yes.
We have branch protection enabled particularly for the master/main, pre-prod, and prod branches. Protected branches require:

Mandatory Merge Requests (MRs)

Successful pipeline execution before merge

No direct push access

Approval from designated reviewers (based on environment)


All functional development follows a structured GitFlow branching model using environment-specific branches (dev â†’ SIT â†’ UAT â†’ pre-prod â†’ prod) with clear naming conventions for feature, bugfix, and hotfix branches.


---

2. What is your current branching strategy? Please explain in detail.

We follow a GitFlow-inspired environment-based branching strategy:

dev branch â†’ primary integration branch for development

sit branch â†’ used for system integration testing

uat branch â†’ user acceptance testing environment

pre-prod branch â†’ staging environment before production

prod branch â†’ production-ready, protected branch


Additionally:

Pre-prod and prod have DR (Disaster Recovery) and DC (Data Center) setups.

All merges between branches occur strictly via Merge Requests.

Feature branches follow the naming convention:
feature/<task-id> or bugfix/<ticket-id>



---

3. Do you currently use any artifacts or dependency management tools?

Yes.
We use RedHat Quay as our artifact container registry:

Stores container images used by GitLab pipelines

Stores versioned images for rollback and release tracking

Integrated with Helm chart deployments


Dependency management is handled through the application languageâ€™s package manager (e.g., npm, pip, Maven, etc.) within CI jobs.


---

4. Which tools are currently integrated with your repositories (e.g., Jira, Jenkins, SonarQube, Slack, Nexus)?

No external tools are currently integrated.
All workflow management, CI/CD, and issue tracking is handled natively within GitLab.


---

5. Are there any specific milestones, issues, or merge requests that need to be migrated?

No migrations are currently needed.
We actively track tasks, bugs, and enhancements using GitLab Issues, and merge requests are tied directly to their corresponding issue references.


---

6. What is the process to resolve conflicts in source code?

Merge conflicts are resolved locally by developers using Git on their workstation.
After fixing and validating locally, the updated code is pushed to the feature branch and re-submitted through the MR for review and merge.


---

7. How many jobs, stages, and scripts are currently used in the current tool?

Our GitLab CI/CD pipeline uses the following stages:

1. .pre


2. build


3. test


4. sast


5. hp-fortify


6. release


7. dockerbuild


8. deploy

deployment

commit

validate

deploy

verify




This pipeline builds the application, performs static code analysis, builds the Docker image, pushes it to Quay, and then deploys it to OpenShift via Helm.


---

8. What is your process for remediating vulnerabilities once identified?

Currently, vulnerability reports (SAST, dependency scanning, Fortify, container security) are:

Reviewed by the development team

Fixed manually based on priority and severity

Re-tested in subsequent pipeline runs


No automated blocking is configured yet, but vulnerabilities are actively addressed during development cycles.


---

9. What are your rollback mechanisms?

We use multiple complementary rollback methods:

Helm upgrade with --atomic
Ensures failed Helm upgrades automatically roll back to the last stable release.

Helm release history
Helm maintains release records, allowing us to run:
helm rollback <release> <revision>

Previous image tags
We maintain versioned image tags in Quay, allowing us to re-run previous GitLab pipelines or redeploy older images.


These combined methods provide reliable rollback for OpenShift workloads.


---

ðŸŽ‰ All questionnaire answers are now complete.

If you want, I can also prepare:

âœ… A professional PDF/Doc version of these answers
âœ… A CI/CD architecture diagram (GitLab â†’ Quay â†’ Helm â†’ RHOCP)
âœ… A rollback workflow diagram
âœ… A GitLab CI template for your environment

Just tell me which format you need.
          number: 8080
